function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/*! (c) Andrea Giammarchi - ISC */
// requires a global Symbol
var iterator = /* istanbul ignore next */
function () {
  var i = 0;
  var self = this;
  return {
    next: function () {
      var done = self.length <= i;
      var value = done ? void 0 : self[i++];
      return {
        value: value,
        done: done
      };
    }
  };
};

function isRegexp(value) {
  return Object.prototype.toString.call(value) === '[object RegExp]';
}

var flagMap = {
  global: 'g',
  ignoreCase: 'i',
  multiline: 'm',
  dotAll: 's',
  sticky: 'y',
  unicode: 'u'
};
function clonedRegexp(regexp, options) {
  if (options === void 0) {
    options = {};
  }

  if (!isRegexp(regexp)) {
    throw new TypeError('Expected a RegExp instance');
  }

  var flags = Object.keys(flagMap).map(function (flag) {
    return (typeof options[flag] === 'boolean' ? options[flag] : regexp[flag]) ? flagMap[flag] : '';
  }).join('');
  var clonedRegexp = new RegExp(options.source || regexp.source, flags);
  clonedRegexp.lastIndex = typeof options.lastIndex === 'number' ? options.lastIndex : regexp.lastIndex;
  return clonedRegexp;
}

var _$exec;
var supportsGroups = ('groups' in ((_$exec = /a/.exec('a')) != null ? _$exec : {}));
/**
 * @param {RegExpExecArray?} previousMatch
 * @param {RegExpExecArray?} match
 */

var isInfiniteLoop = function isInfiniteLoop(previousMatch, match) {
  var isLooselyTrue = (previousMatch == null ? void 0 : previousMatch[0]) === (match == null ? void 0 : match[0]) && (previousMatch == null ? void 0 : previousMatch.index) === (match == null ? void 0 : match.index);

  if (isLooselyTrue) {
    return JSON.stringify(_extends({}, previousMatch)) === JSON.stringify(_extends({}, match));
  }

  return false;
};

var INFINITE_LOOP_ERROR = 'Infinite loop.';
/**
 * @param {string|RegExp} matcher
 * @param {boolean}       skipCloning
 */

function resolveMatcher(matcher, skipCloning) {
  if (skipCloning === void 0) {
    skipCloning = false;
  }

  if (!(matcher instanceof RegExp)) {
    return new RegExp(matcher, 'g');
  }

  if (skipCloning) {
    return matcher;
  }

  return clonedRegexp(matcher);
}
/**
 * Returns an iterator of all results matching a string against a regular expression, including capturing groups.
 *
 * @param   {string}                             string  String to match.
 * @param   {string|RegExp}                      matcher Value to match original string. If a non-`RegExp` object is passed, it is implicitly converted to a `RegExp` by using `new RegExp(regexp, 'g')`. The `RegExp` object must have the `global` flag, otherwise a `TypeError` will be thrown.
 *
 * @returns {IterableIterator<RegExpMatchArray>}
 */


function ponyfill(string, matcher) {
  if (typeof string !== 'string') {
    throw new TypeError('Expected a string');
  }

  var composedMatcher = resolveMatcher(matcher);
  var globalFlag = composedMatcher.global;

  if (!globalFlag) {
    throw new TypeError('`String.prototype.matchAll` ponyfill called with a non-global RegExp argument');
  }
  /** @type {RegExpMatchArray[]} */


  var matches = [];
  var match, previousMatch;

  try {
    previousMatch = null;

    while ((match = composedMatcher.exec(string)) !== null) {
      if (isInfiniteLoop(previousMatch, match)) {
        throw new Error(INFINITE_LOOP_ERROR);
      }

      previousMatch = match;
      matches.push(match);
    }
  } catch (error) {
    /* istanbul ignore if */
    if (!(error instanceof Error && error.message === INFINITE_LOOP_ERROR)) {
      throw error;
    }

    matches.pop();
    string.replace(composedMatcher, function (value, index, input, groups) {
      /** @type {RegExpMatchArray} */
      var match = [value];
      match.index = index;
      match.input = input;

      if (supportsGroups) {
        match.groups = groups;
      }

      matches.push(match);
      return value;
    });
  }

  if (typeof Symbol === 'undefined') {
    // @ts-ignore
    return matches[iterator]();
  }

  return matches[Symbol.iterator]();
}
/**
 * Returns an iterator of all results matching a string against a regular expression, including capturing groups. Uses native implementation if available.
 *
 * @param   {string}                             string  String to match.
 * @param   {string|RegExp}                      matcher Value to match original string. If a non-`RegExp` object is passed, it is implicitly converted to a `RegExp` by using `new RegExp(regexp, 'g')`. The `RegExp` object must have the `global` flag, otherwise a `TypeError` will be thrown.
 *
 * @returns {IterableIterator<RegExpMatchArray>}
 */


function preferNative(string, matcher) {
  if (typeof String.prototype.matchAll !== 'undefined') {
    var composedMatcher = resolveMatcher(matcher, true);
    return string.matchAll(composedMatcher);
  }
  /* istanbul ignore next */


  return ponyfill(string, matcher);
}

export { ponyfill as default, preferNative };
//# sourceMappingURL=index.js.map
